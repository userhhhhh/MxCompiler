
1. 没有被使用的 alloca 可以直接去掉；
2. 如果只被定义了一次，那么所有的使用都可以用定义的值代替；
3. 如果一个 alloca 的定义使用只出现在一个块中，那么每个 use 可以被最近的 def 替换；
4. 如果一个 alloca 只被 load 和 store，那么可以通过在支配边界插入 phi 指令，并将所有的 use 替换为对
   应的 phi 指令的结果。


1、构建控制流图 (CFG)：
    对于每个基本块，记录其后继基本块。形成一个图结构，表示程序的执行路径。
    map<BasicBlock, std::vector<BasicBlock>> CFG;
2、计算支配树 (Dominator Tree)：
    计算每个基本块的支配集合，就是所有必经节点，哪些块一定在哪些块之前执行。
    std::map<BasicBlock, std::set<BasicBlock>> dominators;
    基础算法：
        初始化：设置入口基本块的支配者集合为其自身。其余支配者集合为所有基本块。
        迭代更新每个基本块的支配者集合，直到所有集合不再变化，方法如下：
        新的支配者集合为其所有前驱基本块的支配者集合的交集，再加上该基本块自身
    意义：支配树用于确定变量的作用范围和插入 phi 指令的位置。
3、计算支配边界 (Dominance Frontier)：
    B  
    |  
    D  E
    \ /
     F
    F是D的支配边界，由于D一定经过B，所以F是B的支配边界，同时支配边界要求E的路径必须存在
    A  C
    | /
    B 
    算法：对于每个基本块A，如果A不支配B，则B是A的支配边界。
    意义：支配前驱集合用于确定在何处插入 phi 指令，以合并来自不同路径的值。 
4、维护两个map：
    （allca出的）变量 -> use它的块、def它的块
    块 -> use的变量、def的变量
    这样alloca的前三个消除就实现了
4、插入空的 phi 指令：  
    遍历变量，找到def的块，找到支配边界，如果支配边界用到了，插入phi指令
5、重命名变量：
作用：使用深度优先搜索 (DFS) 遍历基本块，重命名变量以确保每个变量在其作用域内唯一。
意义：重命名变量避免了变量名冲突，确保每个变量在其作用范围内唯一，便于后续优化和代码生成。